<!DOCTYPE html>
<html lang="de">
<head>
    <title>Minecraft Klon (Einstellbarer Nebel)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; font-family: Monospace; background-color: #87CEEB; color: #333; }
        canvas { display: block; }
        #blocker, #menu { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 10; color: white; }
        #menu { display: none; flex-direction: column; text-align: center; }
        .menu-content { background-color: rgba(50, 50, 50, 0.9); padding: 30px; border-radius: 10px; display: flex; flex-direction: column; gap: 15px; min-width: 300px; max-width: 90%; }
        .menu-content h2 { margin-top: 0; }
        .menu-content label { display: block; margin-bottom: 5px; font-weight: bold; text-align: left; }
        .menu-content .checkbox-label { display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 5px 0; }
        .menu-content .checkbox-label input { margin-left: 10px; transform: scale(1.2); cursor: pointer; }
        .menu-content input[type="number"] { padding: 8px; border-radius: 4px; border: 1px solid #ccc; width: 80px; text-align: center; margin-left: 10px; }
        /* Styles for slider */
        .menu-content .slider-label { display: flex; align-items: center; justify-content: space-between; padding: 5px 0;}
        .menu-content input[type="range"] { flex-grow: 1; margin-left: 10px; margin-right: 10px; cursor: pointer;}
        .menu-content .slider-value { min-width: 30px; text-align: right; }

        .menu-content div { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; }
        .menu-content button { padding: 10px 15px; border: none; border-radius: 5px; background-color: #666; color: white; font-size: 16px; cursor: pointer; transition: background-color 0.2s; margin-top: 10px; }
        .menu-content button:hover { background-color: #888; }
        .menu-content button:active { background-color: #555; }
        #instructions { width: 50%; max-width: 400px; background-color: rgba(50, 50, 50, 0.8); padding: 20px; border-radius: 10px; text-align: center; font-size: 16px; cursor: pointer; color: #ffffff; }
        #instructions:hover { background-color: rgba(70, 70, 70, 0.9); }
        .crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border-top: 2px solid white; border-bottom: 2px solid white; border-left: 2px solid white; border-right: 2px solid white; box-sizing: border-box; transform: translate(-50%, -50%); pointer-events: none; opacity: 0.5; display: none; z-index: 5; }
        .crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 2px; background-color: white; transform: translate(-50%, -50%); }
        #block-selector { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background-color: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 5px; z-index: 5; }
        .block-option { width: 40px; height: 40px; border: 2px solid #555; cursor: pointer; background-size: cover; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        .block-option.selected { border: 3px solid #fff; box-shadow: 0 0 10px #fff; }
        #coordsDisplay { position: absolute; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.4); color: white; padding: 5px 10px; border-radius: 3px; font-size: 14px; z-index: 4; display: block; pointer-events: none; }
    </style>
</head>
<body>
    <div id="blocker"> <div id="instructions"> Klicken zum Spielen<br /> (W = Vorwärts, S = Rückwärts)<br> (A = Links, D = Rechts)<br> (Doppel-W = Sprinten)<br> (Maus = Umschauen, Leertaste = Springen, Shift = Ducken)<br> <small>(Linksklick = Platzierten Block entfernen)</small><br> <small>(Rechtsklick = Block setzen)</small><br> <small>(Blocktyp unten auswählen)</small><br> <small>(ESC = Menü öffnen/schließen)</small><br> <small style="color: #ffcc00;">(Kollisions-Optimierung aktiv)</small> </div> </div>
    <div id="menu">
        <div class="menu-content">
            <h2>Menü</h2>
            <div>
                <label for="worldWidthInput">Weltbreite:</label>
                <input type="number" id="worldWidthInput" min="16" max="128" step="16">
            </div>
            <div>
                <label for="worldDepthInput">Welttiefe:</label>
                <input type="number" id="worldDepthInput" min="16" max="128" step="16">
            </div>
            <label class="checkbox-label" for="showCoordsCheckbox">
                Koordinaten anzeigen
                <input type="checkbox" id="showCoordsCheckbox">
            </label>
            <label class="checkbox-label" for="fogCheckbox">
                Nebel An/Aus
                <input type="checkbox" id="fogCheckbox">
            </label>
            <label class="slider-label" for="fogDistanceSlider">
                Nebel-Distanz:
                <input type="range" id="fogDistanceSlider" min="20" max="150" step="5">
                <span id="fogDistanceValue"></span>
            </label>
            <label class="checkbox-label" for="noclipCheckbox">
                Noclip An/Aus
                <input type="checkbox" id="noclipCheckbox">
            </label>
            <label class="checkbox-label" for="flyCheckbox">
                Fliegen An/Aus
                <input type="checkbox" id="flyCheckbox">
            </label>
            <button id="restartButton">Neu Generieren</button>
            <button id="resumeButton">Fortsetzen</button>
        </div>
    </div>
    <div id="coordsDisplay">X: 0.0 | Y: 0.0 | Z: 0.0</div>
    <div class="crosshair" id="crosshair"></div>
    <div id="block-selector"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

        // --- Global Variables ---
        let camera, scene, renderer, controls;
        let playerObject;
        const dynamicObjects = [];
        let raycaster;

        // Movement
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isShiftDown = false, onGround = false, isInWater = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let isSprinting = false;
        let lastWPressTime = 0;
        const doubleTapDelay = 300;

        // Player dimensions
        const playerHeightStanding = 1.9;
        const playerHeightCrouching = 0.9;
        const crouchPositionOffsetY = 0.5;

        // World Settings
        let worldWidth = 48, worldDepth = 48;
        let worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
        const blockSize = 1;
        const maxTerrainHeight = 15;
        const seaLevel = -1;

        // Block Materials & Selection
        let grassMaterial, dirtMaterial, stoneMaterial, waterMaterial;
        const blockMaterials = {};
        let selectedBlockType = 'grass';
        const cubeGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

        // --- Spatial Grid ---
        let spatialGrid = {};
        const cellSize = 4;

        // --- Terrain Data ---
        let terrainData;
        let startX, startY, startZ;

        // Game State
        let isGamePaused = false;
        let showCoords = true;
        let fogEnabled = true;
        let noclipEnabled = false;
        let flyModeEnabled = false;
        let fogDistance = Math.max(30, worldWidth * 0.8); // *** Initial Fog Distance ***

        // DOM Elements
        let coordsDisplayElement;
        let blockerElement;
        let fogCheckbox, noclipCheckbox, flyCheckbox, fogDistanceSlider, fogDistanceValue; // Menu elements

        // --- Texture Generation ---
        function createPixelTexture(c1, c2, c3, size = 16) { /* ... (no changes) ... */
            const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const context = canvas.getContext('2d'); context.imageSmoothingEnabled = false; for (let y = 0; y < size; y++) { for (let x = 0; x < size; x++) { const rand = Math.random(); if (rand < 0.6) context.fillStyle = c1; else if (rand < 0.85) context.fillStyle = c2; else context.fillStyle = c3; context.fillRect(x, y, 1, 1); } } const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter; texture.colorSpace = THREE.SRGBColorSpace; return texture;
         }
        function createWaterTexture(c1 = '#4488FF', c2 = '#3377EE', c3 = '#5599FF', size = 16) { /* ... (no changes) ... */
             const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const context = canvas.getContext('2d'); context.imageSmoothingEnabled = false; for (let y = 0; y < size; y++) { for (let x = 0; x < size; x++) { const rand = Math.random(); let baseColor = c1; if (Math.sin(x * 0.8 + y * 0.4) > 0.3) baseColor = c2; if (rand < 0.7) context.fillStyle = baseColor; else context.fillStyle = c3; context.fillRect(x, y, 1, 1); } } const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter; texture.colorSpace = THREE.SRGBColorSpace; return texture;
         }

        // --- Spatial Grid Helpers ---
        function getCellCoords(x, z) { return { x: Math.floor(x / cellSize), z: Math.floor(z / cellSize) }; }
        function getCellKey(cellX, cellZ) { return `${cellX}_${cellZ}`; }
        function addObjectToGrid(obj) { /* ... (no changes) ... */
            if (!(obj instanceof THREE.Mesh)) return; const pos = obj.position; const cellCoords = getCellCoords(pos.x, pos.z); const key = getCellKey(cellCoords.x, cellCoords.z); if (!spatialGrid[key]) spatialGrid[key] = []; if (!spatialGrid[key].includes(obj)) spatialGrid[key].push(obj);
         }
        function removeObjectFromGrid(obj) { /* ... (no changes) ... */
             if (!(obj instanceof THREE.Mesh)) return; const pos = obj.position; const cellCoords = getCellCoords(pos.x, pos.z); const key = getCellKey(cellCoords.x, cellCoords.z); if (spatialGrid[key]) { const index = spatialGrid[key].indexOf(obj); if (index > -1) spatialGrid[key].splice(index, 1); }
         }
        function getNearbyBlocks(x, z, radius = 1) { /* ... (no changes) ... */
            const nearby = new Set(); const centerCell = getCellCoords(x, z); for (let i = -radius; i <= radius; i++) { for (let j = -radius; j <= radius; j++) { const key = getCellKey(centerCell.x + i, centerCell.z + j); if (spatialGrid[key]) { spatialGrid[key].forEach(item => { if (item instanceof THREE.Mesh) { nearby.add(item); } }); } } } return Array.from(nearby);
         }


        // --- Initialization ---
        window.onload = () => {
            coordsDisplayElement = document.getElementById('coordsDisplay');
            blockerElement = document.getElementById('blocker');
            fogCheckbox = document.getElementById('fogCheckbox');
            noclipCheckbox = document.getElementById('noclipCheckbox');
            flyCheckbox = document.getElementById('flyCheckbox');
            fogDistanceSlider = document.getElementById('fogDistanceSlider');
            fogDistanceValue = document.getElementById('fogDistanceValue');
            setupMenuControls();
            init();
            animate();
        };

        function generateHeight(width, height) { /* ... (no changes) ... */
             const data = [], perlin = new ImprovedNoise(), size = width * height; const z = Math.random() * 100; let quality = 1; for (let j = 0; j < 4; j++) { if (j === 0) for (let i = 0; i < size; i++) data[i] = 0; for (let i = 0; i < size; i++) { const x = i % width, y = Math.floor(i / width); data[i] += perlin.noise(x / quality, y / quality, z) * quality; } quality *= 5; } return data;
         }
        function getY(x, z) { /* ... (no changes) ... */
            const clampedX = Math.max(0, Math.min(worldWidth - 1, Math.floor(x + worldHalfWidth))); const clampedZ = Math.max(0, Math.min(worldDepth - 1, Math.floor(z + worldHalfDepth))); if (!terrainData) return 0; const height = Math.floor(terrainData[clampedX + clampedZ * worldWidth] * 0.1); return Math.min(maxTerrainHeight, Math.max(-5, height));
         }

        // --- Cloud Generation Function Removed ---


        // Main initialization function
        function init() {
            console.log(`Initializing world: ${worldWidth}x${worldDepth}`);
            isGamePaused = false;
            // simulationTime = 0; // Removed

            // --- Cleanup previous scene/controls if exists ---
            if (scene) {
                 if (controls) { controls.dispose(); controls = null; }
                 if (playerObject) scene.remove(playerObject);
                while(scene.children.length > 0){ const obj = scene.children[0]; scene.remove(obj); if (obj instanceof THREE.Mesh && obj.geometry) obj.geometry.dispose(); if (obj instanceof THREE.Mesh && obj.material) { if (obj.material.map && obj.material.map.dispose) obj.material.map.dispose(); obj.material.dispose(); } }
             }
             Object.keys(blockMaterials).forEach(key => { const mat = blockMaterials[key]; if (mat) { if (mat.map && mat.map.dispose) mat.map.dispose(); mat.dispose(); } delete blockMaterials[key]; });

             dynamicObjects.length = 0; spatialGrid = {};
            terrainData = generateHeight(worldWidth, worldDepth);

            // Create Materials
            const grassTexture = createPixelTexture('#559022', '#66bb66', '#447711'); const dirtTexture = createPixelTexture('#8B4513', '#A0522D', '#654321'); const stoneTexture = createPixelTexture('#808080', '#A9A9A9', '#696969'); const waterTexture = createWaterTexture();
            grassMaterial = new THREE.MeshLambertMaterial({ map: grassTexture }); dirtMaterial = new THREE.MeshLambertMaterial({ map: dirtTexture }); stoneMaterial = new THREE.MeshLambertMaterial({ map: stoneTexture }); waterMaterial = new THREE.MeshLambertMaterial({ map: waterTexture, transparent: true, opacity: 0.75 });
            blockMaterials['grass'] = grassMaterial; blockMaterials['dirt'] = dirtMaterial; blockMaterials['stone'] = stoneMaterial; blockMaterials['water'] = waterMaterial;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // *** Add Fog based on initial state and distance ***
            setFog(); // Call helper function

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            playerObject = new THREE.Object3D(); playerObject.add(camera); camera.position.set(0, 0.15, 0); scene.add(playerObject);
            startX = 0; startZ = 0; const startPlayerHalfHeight = playerHeightStanding / 2; startY = (getY(startX, startZ) + startPlayerHalfHeight + 0.1) * blockSize; startY = Math.max(startY, (seaLevel + startPlayerHalfHeight + 0.1) * blockSize); playerObject.position.set(startX * blockSize, startY, startZ * blockSize);

            if (!renderer) { renderer = new THREE.WebGLRenderer({ antialias: false }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); }

            // Lighting
            const hemisphereLight = new THREE.HemisphereLight(0xeeeeff, 0x777788, 1.0); scene.add(hemisphereLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8); directionalLight.position.set(50, 80, 30); scene.add(directionalLight);

            // Controls
            controls = new PointerLockControls(playerObject, document.body); setupControlListeners();

            // Interaction Setup
            if (!raycaster) { raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 6 * blockSize); }
            document.addEventListener('mousedown', onMouseDown);

            // --- Sun/Moon Removed ---

            // --- World Generation ---
            console.log(`Generating world meshes and populating spatial grid (${worldWidth}x${worldDepth})...`); const generationStartTime = performance.now(); for (let x = -worldHalfWidth; x < worldHalfWidth; x++) { for (let z = -worldHalfDepth; z < worldHalfDepth; z++) { const terrainHeight = getY(x, z); const solidHeight = Math.max(terrainHeight, seaLevel); for (let y = -5; y < solidHeight; y++) { let material = stoneMaterial; if (y >= seaLevel && y >= terrainHeight - 1) material = grassMaterial; else if (y >= seaLevel && y >= terrainHeight - 4) material = dirtMaterial; if (y < seaLevel && terrainHeight <= y) continue; const block = new THREE.Mesh(cubeGeometry, material); block.position.set( x * blockSize + blockSize / 2, y * blockSize + blockSize / 2, z * blockSize + blockSize / 2 ); scene.add(block); addObjectToGrid(block); } if (terrainHeight < seaLevel) { for (let y = terrainHeight; y < seaLevel; y++) { const waterBlock = new THREE.Mesh(cubeGeometry, waterMaterial); waterBlock.position.set( x * blockSize + blockSize / 2, y * blockSize + blockSize / 2, z * blockSize + blockSize / 2 ); waterBlock.userData.isWater = true; scene.add(waterBlock); addObjectToGrid(waterBlock); } } } } const generationEndTime = performance.now(); console.log(`World generation took ${(generationEndTime - generationStartTime).toFixed(2)} ms`);

            // Setup UI & Resize Listener
            setupBlockSelectorUI(); if (!window.onresize) { window.addEventListener('resize', onWindowResize); } document.getElementById('worldWidthInput').value = worldWidth; document.getElementById('worldDepthInput').value = worldDepth;
            coordsDisplayElement.style.display = showCoords ? 'block' : 'none';
            // Set initial menu control values
            fogCheckbox.checked = fogEnabled;
            noclipCheckbox.checked = noclipEnabled;
            flyCheckbox.checked = flyModeEnabled;
            fogDistanceSlider.value = fogDistance;
            fogDistanceValue.textContent = fogDistance;
            fogDistanceSlider.max = Math.max(150, worldWidth * 1.5); // Adjust slider max based on world size
        }

        // --- Setup Listeners (Called AFTER controls are created) ---
        function setupControlListeners() { /* ... (no changes) ... */
             const instructions = document.getElementById('instructions'); const crosshair = document.getElementById('crosshair'); const menu = document.getElementById('menu'); if (!blockerElement) blockerElement = document.getElementById('blocker');
             const lockControls = () => { if(controls) controls.lock(); };
             const onLock = () => { if (!isGamePaused) { blockerElement.style.display = 'none'; crosshair.style.display = 'block'; menu.style.display = 'none'; } };
             const onUnlock = () => { if (!isGamePaused) { blockerElement.style.display = 'flex'; } crosshair.style.display = 'none'; };
             instructions.onclick = lockControls;
             if (controls) { controls.addEventListener('lock', onLock); controls.addEventListener('unlock', onUnlock); }
             document.removeEventListener('keydown', onKeyDown); document.removeEventListener('keyup', onKeyUp); document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
         }

        // Define key handlers outside setup so they can be referenced for removal
        const onKeyDown = (event) => { /* ... (no changes) ... */
            if (event.code === 'Escape') { toggleMenu(); return; } if (isGamePaused) return; switch (event.code) { case 'KeyW': moveForward = true; const timeNow = performance.now(); if (timeNow - lastWPressTime < doubleTapDelay) { isSprinting = true; } lastWPressTime = timeNow; break; case 'KeyA': moveLeft = true; break; case 'KeyS': moveBackward = true; isSprinting = false; break; case 'KeyD': moveRight = true; break; case 'Space': if (flyModeEnabled) { velocity.y += 1; } else if (onGround || isInWater || canJump) { velocity.y += isInWater ? 6.0 : 10.0; canJump = false; onGround = false; isInWater = false; /* isSprinting = false; */ } break; case 'ShiftLeft': case 'ShiftRight': if (flyModeEnabled) { velocity.y -= 1; } else { if (!isShiftDown && playerObject) { playerObject.position.y -= crouchPositionOffsetY; } isShiftDown = true; isSprinting = false; } break; case 'Digit1': selectBlock('grass'); break; case 'Digit2': selectBlock('dirt'); break; case 'Digit3': selectBlock('stone'); break; case 'Digit4': selectBlock('water'); break; }
        };
        const onKeyUp = (event) => { /* ... (no changes) ... */
                if (isGamePaused && event.code !== 'Escape') return; switch (event.code) { case 'KeyW': moveForward = false; isSprinting = false; break; case 'KeyA': moveLeft = false; break; case 'KeyS': moveBackward = false; break; case 'KeyD': moveRight = false; break; case 'ShiftLeft': case 'ShiftRight': if (!flyModeEnabled) { if (isShiftDown && playerObject) { playerObject.position.y += crouchPositionOffsetY; } isShiftDown = false; } break; }
        };


        function setupMenuControls() {
             const menu = document.getElementById('menu'); const resumeButton = document.getElementById('resumeButton'); const restartButton = document.getElementById('restartButton'); const widthInput = document.getElementById('worldWidthInput'); const depthInput = document.getElementById('worldDepthInput'); const showCoordsCheckbox = document.getElementById('showCoordsCheckbox');
             fogCheckbox = document.getElementById('fogCheckbox'); noclipCheckbox = document.getElementById('noclipCheckbox'); flyCheckbox = document.getElementById('flyCheckbox'); fogDistanceSlider = document.getElementById('fogDistanceSlider'); fogDistanceValue = document.getElementById('fogDistanceValue'); // Get elements

             resumeButton.addEventListener('click', toggleMenu);
             restartButton.addEventListener('click', () => {
                 const newWidth = parseInt(widthInput.value, 10); const newDepth = parseInt(depthInput.value, 10); if (isNaN(newWidth) || isNaN(newDepth) || newWidth < 16 || newWidth > 128 || newDepth < 16 || newDepth > 128) { alert("Bitte gültige Weltgröße eingeben (Breite/Tiefe: 16-128)."); return; }
                 moveForward = false; moveBackward = false; moveLeft = false; moveRight = false; isSprinting = false; isShiftDown = false; velocity.set(0, 0, 0);
                 worldWidth = newWidth; worldDepth = newDepth; worldHalfWidth = worldWidth / 2; worldHalfDepth = worldDepth / 2;
                 // *** Update fog distance slider max based on new world size ***
                 fogDistanceSlider.max = Math.max(150, worldWidth * 1.5);
                 // *** Reset fog distance to default for new world size? Or keep user setting? Keep for now. ***
                 // fogDistance = Math.max(30, worldWidth * 0.8);
                 // fogDistanceSlider.value = fogDistance;
                 // fogDistanceValue.textContent = fogDistance;

                 menu.style.display = 'none'; isGamePaused = false;
                 init(); // Re-initialize the world
                 blockerElement.style.display = 'flex'; // Show blocker
             });
             showCoordsCheckbox.addEventListener('change', () => { showCoords = showCoordsCheckbox.checked; coordsDisplayElement.style.display = showCoords ? 'block' : 'none'; });
             fogCheckbox.addEventListener('change', () => {
                 fogEnabled = fogCheckbox.checked;
                 setFog(); // Update fog state
             });
             // *** Add listener for fog slider ***
             fogDistanceSlider.addEventListener('input', () => {
                 fogDistance = parseFloat(fogDistanceSlider.value);
                 fogDistanceValue.textContent = fogDistance.toFixed(0);
                 setFog(); // Update fog state
             });
             noclipCheckbox.addEventListener('change', () => {
                 noclipEnabled = noclipCheckbox.checked; if (!noclipEnabled && flyModeEnabled) { flyCheckbox.checked = false; flyModeEnabled = false; }
             });
             flyCheckbox.addEventListener('change', () => {
                 flyModeEnabled = flyCheckbox.checked; if (flyModeEnabled) { noclipEnabled = true; noclipCheckbox.checked = true; velocity.y = 0; } else { noclipEnabled = false; noclipCheckbox.checked = false; }
             });

             // Set initial menu state
             widthInput.value = worldWidth; depthInput.value = worldDepth; showCoordsCheckbox.checked = showCoords;
             fogCheckbox.checked = fogEnabled; noclipCheckbox.checked = noclipEnabled; flyCheckbox.checked = flyModeEnabled;
             fogDistanceSlider.value = fogDistance; fogDistanceValue.textContent = fogDistance.toFixed(0);
             fogDistanceSlider.max = Math.max(150, worldWidth * 1.5); // Initial max based on world size
         }

        // *** Helper function to set/update fog ***
        function setFog() {
            if (fogEnabled) {
                const fogColor = 0x87CEEB;
                const far = fogDistance;
                const near = far * 0.2; // Keep near proportional to far distance
                if (!scene.fog) {
                    scene.fog = new THREE.Fog(fogColor, near, far);
                    scene.userData.fog = scene.fog; // Store ref if needed elsewhere
                } else {
                    scene.fog.near = near;
                    scene.fog.far = far;
                    scene.fog.color.set(fogColor); // Ensure color is correct
                }
            } else {
                scene.fog = null;
            }
        }


        function toggleMenu() {
            const menu = document.getElementById('menu');
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                // Update checkboxes/sliders to reflect current state when opening menu
                document.getElementById('showCoordsCheckbox').checked = showCoords;
                fogCheckbox.checked = fogEnabled;
                noclipCheckbox.checked = noclipEnabled;
                flyCheckbox.checked = flyModeEnabled;
                fogDistanceSlider.value = fogDistance;
                fogDistanceValue.textContent = fogDistance.toFixed(0);
                menu.style.display = 'flex';
                if(controls) controls.unlock();
            } else {
                menu.style.display = 'none';
                if(controls) controls.lock();
            }
            console.log("Game Paused:", isGamePaused);
         }

        function onWindowResize() { /* ... (no changes) ... */
             if (camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
         }
        function setupBlockSelectorUI() { /* ... (no changes) ... */
            const selector = document.getElementById('block-selector'); selector.innerHTML = ''; Object.keys(blockMaterials).forEach(type => { const option = document.createElement('div'); option.classList.add('block-option'); option.dataset.type = type; const material = blockMaterials[type]; const texture = material.map; if (texture && texture.image instanceof HTMLCanvasElement) { option.style.backgroundImage = `url(${texture.image.toDataURL()})`; } else { option.style.backgroundColor = material.color ? `#${material.color.getHexString()}` : '#ccc'; } if (type === 'water') { option.style.opacity = '0.75'; } else { option.style.opacity = '1'; } option.addEventListener('click', () => { selectBlock(type); }); selector.appendChild(option); }); updateSelectedBlockHighlight();
         }
        function selectBlock(type) { /* ... (no changes) ... */
             if (blockMaterials[type]) { selectedBlockType = type; console.log("Selected block:", selectedBlockType); updateSelectedBlockHighlight(); }
         }
        function updateSelectedBlockHighlight() { /* ... (no changes) ... */
            const options = document.querySelectorAll('.block-option'); options.forEach(opt => { if (opt.dataset.type === selectedBlockType) opt.classList.add('selected'); else opt.classList.remove('selected'); });
         }

        // --- Mouse Interaction ---
        function onMouseDown(event) { /* ... (no changes) ... */
            if (isGamePaused || !controls || !controls.isLocked) return; raycaster.setFromCamera({ x: 0, y: 0 }, camera); const nearbyObjectsForRaycast = getNearbyBlocks(playerObject.position.x, playerObject.position.z, 2); const intersects = raycaster.intersectObjects(nearbyObjectsForRaycast, false); if (intersects.length > 0) { const intersect = intersects[0]; if (intersect.distance > 6 * blockSize) return; if (event.button === 0) { if (intersect.object.position.y < (-4 * blockSize)) return; removeObjectFromGrid(intersect.object); const index = dynamicObjects.indexOf(intersect.object); if (index > -1) dynamicObjects.splice(index, 1); scene.remove(intersect.object); console.log("Removed block."); } else if (event.button === 2) { const placementPos = new THREE.Vector3().copy(intersect.point).add(intersect.face.normal.clone().multiplyScalar(0.01)); placementPos.divideScalar(blockSize).floor().multiplyScalar(blockSize).addScalar(blockSize / 2); let occupied = false; const nearbyForPlacementCheck = getNearbyBlocks(placementPos.x, placementPos.z, 0); for (const obj of nearbyForPlacementCheck) { if (obj.position.distanceToSquared(placementPos) < 0.1) { occupied = true; break; } } const playerHeight = isShiftDown ? playerHeightCrouching : playerHeightStanding; const playerWidth = 0.4 * blockSize; const playerHeadPos = playerObject.position.clone().add(new THREE.Vector3(0, playerHeight/2 - 0.1, 0)); const playerFeetPos = playerObject.position.clone().add(new THREE.Vector3(0, -playerHeight/2 + 0.1, 0)); const newBlockBox = new THREE.Box3().setFromCenterAndSize(placementPos, new THREE.Vector3(blockSize, blockSize, blockSize)); if (!occupied && !(newBlockBox.containsPoint(playerHeadPos) || newBlockBox.containsPoint(playerFeetPos) || (Math.abs(placementPos.x - playerObject.position.x) < playerWidth + blockSize/2 && Math.abs(placementPos.z - playerObject.position.z) < playerWidth + blockSize/2 && placementPos.y > playerFeetPos.y && placementPos.y < playerHeadPos.y))) { const selectedMaterial = blockMaterials[selectedBlockType] || stoneMaterial; const voxel = new THREE.Mesh(cubeGeometry, selectedMaterial); voxel.position.copy(placementPos); if (selectedBlockType === 'water') { voxel.userData.isWater = true; } scene.add(voxel); dynamicObjects.push(voxel); addObjectToGrid(voxel); } else { console.log("Cannot place block here (occupied or inside player)."); } } } else { console.log("No block intersected."); }
         }


        // --- Animation Loop ---
        // Removed day/night cycle logic

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min(0.1, (time - prevTime) / 1000);
            prevTime = time;

            if (showCoords && coordsDisplayElement && playerObject) { const playerPos = playerObject.position; coordsDisplayElement.textContent = `X: ${playerPos.x.toFixed(1)} | Y: ${playerPos.y.toFixed(1)} | Z: ${playerPos.z.toFixed(1)}`; }
            if (!renderer || !scene || !camera) return;
            renderer.render(scene, camera);

            if (isGamePaused || !controls || !controls.isLocked) { return; }

            const playerHeight = isShiftDown && !flyModeEnabled ? playerHeightCrouching : playerHeightStanding;
            const playerHalfHeight = playerHeight / 2;
            const gravity = 30.0;
            let baseMoveSpeed;
            if (isSprinting && !isShiftDown && !flyModeEnabled) { baseMoveSpeed = 50.0; }
            else if (isShiftDown && !flyModeEnabled) { baseMoveSpeed = 12.5; }
            else if (flyModeEnabled) { baseMoveSpeed = 25.0; }
            else { baseMoveSpeed = 25.0; }
            const jumpVelocity = 10.0;
            const damping = 10.0;
            isInWater = false;

            const playerPos = playerObject.position;
            const originalPos = playerPos.clone();
            const playerWidth = 0.4 * blockSize;
            let wasOnGround = onGround;
            onGround = false;

            const nearbyBlocks = getNearbyBlocks(playerPos.x, playerPos.z);
            const tempBox = new THREE.Box3();

            // Check if in water
            if (!flyModeEnabled && !noclipEnabled) {
                const playerFeetCheckY = playerPos.y - playerHalfHeight + 0.1; const playerHeadCheckY = playerPos.y + playerHalfHeight - 0.1;
                for (const obj of nearbyBlocks) { if (obj.userData.isWater) { tempBox.setFromObject(obj); if (playerPos.x > tempBox.min.x && playerPos.x < tempBox.max.x && playerPos.z > tempBox.min.z && playerPos.z < tempBox.max.z && playerHeadCheckY > tempBox.min.y && playerFeetCheckY < tempBox.max.y) { isInWater = true; break; } } }
            }

            // Adjust physics
            const applyGravity = !flyModeEnabled && !noclipEnabled;
            const currentGravity = isInWater ? gravity * 0.5 : gravity; const currentMoveSpeed = isInWater && !flyModeEnabled ? baseMoveSpeed * 0.5 : baseMoveSpeed; const currentDamping = isInWater && !flyModeEnabled ? damping * 2.0 : damping;

            // Apply Gravity & Damping
            if (applyGravity) { if (!onGround || velocity.y > 0) velocity.y -= currentGravity * delta; }
            else { velocity.y -= velocity.y * damping * delta; } // Apply damping to vertical fly/noclip speed
            velocity.x -= velocity.x * currentDamping * delta;
            velocity.z -= velocity.z * currentDamping * delta;

            // Calculate Movement & Apply Velocity
            direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize();
            const cameraDirection = controls.getDirection(new THREE.Vector3(0, 0, -1)); const rightDirection = new THREE.Vector3().crossVectors(camera.up, cameraDirection).normalize(); const moveFactor = currentMoveSpeed * delta;
            velocity.x += cameraDirection.x * direction.z * moveFactor; velocity.z += cameraDirection.z * direction.z * moveFactor;
            velocity.x -= rightDirection.x * direction.x * moveFactor; // A/D Fixed Sign
            velocity.z -= rightDirection.z * direction.x * moveFactor; // A/D Fixed Sign

            // --- Collision Detection (Skip if Noclip) ---
            if (!noclipEnabled) {
                // --- Y-AXIS COLLISION ---
                let hitGround = false; let hitCeiling = false; let highestGroundY = -Infinity;
                const verticalMovement = velocity.y * delta; const anticipatedPlayerY = playerPos.y + verticalMovement;
                const groundCheckTolerance = 0.1; const ceilingCheckTolerance = 0.2; const verticalProximityLimit = 1.5 * blockSize;
                for (const item of nearbyBlocks) {
                    if (item.userData.isWater) continue; const itemPos = item.position; tempBox.setFromObject(item);
                    const blockTopY = tempBox.max.y; const blockBottomY = tempBox.min.y;
                    const playerFeet = anticipatedPlayerY - playerHalfHeight; const playerHead = anticipatedPlayerY + playerHalfHeight;
                    const horizontalOverlapMargin = 0.001;
                    if (playerPos.x + playerWidth > tempBox.min.x + horizontalOverlapMargin && playerPos.x - playerWidth < tempBox.max.x - horizontalOverlapMargin &&
                        playerPos.z + playerWidth > tempBox.min.z + horizontalOverlapMargin && playerPos.z - playerWidth < tempBox.max.z - horizontalOverlapMargin) {
                        if (velocity.y > 0 && playerHead > blockBottomY - ceilingCheckTolerance && originalPos.y + playerHalfHeight <= blockBottomY + ceilingCheckTolerance) { velocity.y = 0; hitCeiling = true; }
                        if (velocity.y <= 0 && playerFeet < blockTopY + groundCheckTolerance && originalPos.y - playerHalfHeight >= blockTopY - groundCheckTolerance && originalPos.y - playerHalfHeight < blockTopY + verticalProximityLimit) { if (blockTopY > highestGroundY) { highestGroundY = blockTopY; } hitGround = true; }
                    }
                }
                if (hitGround) { playerPos.y = highestGroundY + playerHalfHeight + 0.001; velocity.y = 0; onGround = true; canJump = true; }
                else if (hitCeiling) { playerPos.y = originalPos.y; if (velocity.y > 0) velocity.y = 0; onGround = false; }
                else { playerPos.y = anticipatedPlayerY; onGround = false; if (wasOnGround) canJump = false; }

                // --- X-AXIS COLLISION ---
                playerPos.x += velocity.x * delta;
                const collisionOffset = 0.03;
                for (const item of nearbyBlocks) { if (item.userData.isWater) continue; tempBox.setFromObject(item); const playerFeet = playerPos.y - playerHalfHeight; const playerHead = playerPos.y + playerHalfHeight; if (playerHead > tempBox.min.y && playerFeet < tempBox.max.y && playerPos.z + playerWidth > tempBox.min.z && playerPos.z - playerWidth < tempBox.max.z) { if (velocity.x > 0 && playerPos.x + playerWidth > tempBox.min.x && originalPos.x + playerWidth <= tempBox.min.x + collisionOffset) { playerPos.x = tempBox.min.x - playerWidth - collisionOffset; velocity.x = 0; break; } if (velocity.x < 0 && playerPos.x - playerWidth < tempBox.max.x && originalPos.x - playerWidth >= tempBox.max.x - collisionOffset) { playerPos.x = tempBox.max.x + playerWidth + collisionOffset; velocity.x = 0; break; } } }

                // --- Z-AXIS COLLISION ---
                playerPos.z += velocity.z * delta;
                for (const item of nearbyBlocks) { if (item.userData.isWater) continue; tempBox.setFromObject(item); const playerFeet = playerPos.y - playerHalfHeight; const playerHead = playerPos.y + playerHalfHeight; if (playerHead > tempBox.min.y && playerFeet < tempBox.max.y && playerPos.x + playerWidth > tempBox.min.x && playerPos.x - playerWidth < tempBox.max.x) { if (velocity.z > 0 && playerPos.z + playerWidth > tempBox.min.z && originalPos.z + playerWidth <= tempBox.min.z + collisionOffset) { playerPos.z = tempBox.min.z - playerWidth - collisionOffset; velocity.z = 0; break; } if (velocity.z < 0 && playerPos.z - playerWidth < tempBox.max.z && originalPos.z - playerWidth >= tempBox.max.z - collisionOffset) { playerPos.z = tempBox.max.z + playerWidth + collisionOffset; velocity.z = 0; break; } } }

            } else { // Noclip enabled: Apply movement directly
                 playerPos.y += velocity.y * delta;
                 playerPos.x += velocity.x * delta;
                 playerPos.z += velocity.z * delta;
                 onGround = false; canJump = false;
            }


            // Fallback / Safety Net
            if (playerPos.y < -50) { console.warn("Player fell through world, resetting position."); playerPos.set(startX * blockSize, startY, startZ * blockSize); velocity.set(0, 0, 0); onGround = true; canJump = true; isInWater = false; }

            // renderer.render(scene, camera); // Moved to top
        }
    </script>
</body>
</html>
